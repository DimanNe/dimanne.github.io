title: Truly Secure Boot + Yubikey 


# **_Truly_ Secure Boot + Yubikey**

TL;DR:

Here we are going to sign everything pertaining to the boot process (including `grub.cfg` and `initrd`) with your **own** keys. Jump directly to Step-by-step instructions.

## Boot process digest

##### CPU firmware

1. Loosely speaking, "CPU inside CPU" starts first. More precisely, Firmware inside PCH (platform controller hub) or BMC (baseboard management controller) is executed first. Intel Management Engine runs in the PCH and starts before the CPU.
2. It performs basic hardware configuration and allows the CPU to come out of reset.
3. The first instruction that CPU executes is the instruction from 16-bytes below 4GB.
    - What is there?"
        * SPI flash memory is mapped to the top of the 32-bit address space.
        * Reads are forwarded by the chipset to the flash device.
        * The instruction at 0xFFFFFFF0 is a JMP instruction to the start of the UEFI platform initialization code (SEC phase)
    - Other relevant low-level things and keywords:
        - The Boot Block: SEC and PEI phase code.
        - Variable store for UEFI Variables and default settings.
        - SEC Phase sets up the UEFI environment and passes control to PEI Core.
        - PEI Dispatcher dispatches PEI Modules (PEIMs) that perform early hardware and memory initialization.
        - PEI Core passes control to DXE Core.
        - DXE drivers perform additional hardware initialization and configuration.

##### UEFI firmware

UEFI firmware allows users to enroll (add) their own SSL certificates (this can and should be protected with a password). So, given certificates it verifies everything up to (and including) first-stage bootloader (`shim`).

1. UEFI firmware mounts first partition (which is expected to have partition ID of `0xEF00` and be formatted as a FAT32 filesystem). UEFI-bootable binaries are then stored as files in the `/EFI/BOOT/` directory.
2. UEFI firmware verifies signatures of EFI executables using SSL certificates and hashsums.
   - There are several types of certificates and hashsum stores:
      - Platform Key (PK) stores (usually) a single certificate. Does not sign executables directly, but signs other keys.
      - Key Exchange Key (KEK) can store multiple certificates.
      - Blacklist (dbx) and whitelist (db). They can store both certificates and hashsums.
   - A certificate is a public key. Below is how signing and verification works. Remember that only you have private key, and everyone else (including UEFI firmware) - public key.
      - Signing: You calculate a hash of a module and encrypt it with your private key. Then you attach the result (signature) to a file (UEFI module in our case).
      - Verification: The idea is to get (presumably) the same hash in two independent ways and compare them. The 1st way: decrypt the attached signature with the public key (which UEFI has). The 2nd way: calculate hash ourselves (given the module file). If they are equal UEFI knows that the module was created and placed there by whoever poses and controls private key.
   - A certificates has certain capabilities. For example, certificates generated by `update-secureboot-policy` can only sign kernel modules (KeyUsage OID (1.3.6.1.4.1.2312.16.1.2)). They are stored at local file-system.
3. (Unless UEFI firmware is configured for multi-boot), UEFI executes a EFI binary with the default name, which is `BOOTX64.EFI`. In case of Linux, the binary is `shim`.
   - To add a new EFI binary to your firmware's list of available binaries, you should use the `efibootmgr` utility.

##### Shim

In addition to the aforementioned PK/KEK/DB/DBX, `shim` uses its own storage of keys and certificates called MOK (machine owner keys). Shim is supposed to verify everything else: second-stage bootloader (GRUB), kernel, kernel drivers. Shim can:

- start `MokManager`. `MokManager` allows a user to enroll keys, remove trusted keys, enroll binary hashes and toggle Secure Boot validation at the `shim` level. Unfortunately, `MokManager` does not have any protection from an adversary - it allows anyone to enroll new certificates, and does not require any protection - [it is too helpful](https://askubuntu.com/a/1334366/826568). So, in this guide we will remove it completely.
- or `shim`
  1. verifies GRUB and Linux kernel.
  2. Shim then passes execution to GRUB.

##### GRUB

This is the point where _UEFI_'s SecureBoot starts to fade away. While GRUB performs checks of some files (linux kernel - `vmlinuz`) using UEFI's certificates, it does not check everything that it loads and uses with _UEFI_ certificates. Luckily, GRUB has an option to check everything that it loads with GPG keys (a mechanism that is completely unrelated to UEFI certificates, but conceptually similar to what UEFI does). So, GRUB:

1. Reads and loads its own config from `/boot/grub/` (which means that the the configs has to be protected from tampering - we will sign GRUB config with GPG).
2. Provides user with a bunch of options (including rescue shell) as to how to proceed (so, this is another thing that has to be protected - we will create a special GRUB superuser + password).
3. Loads initrd and kernel in memory and passes execution to the kernel (we will sign both initrd and kernel with GPG).
   - initrd is a tiny part of user-space of a real OS, the only purposes of which is to figure-out how to proceed booting (mounting disks, decrypting, loading from NFS, handling DHCP and so on...). The `init` script is the main entry point. More info [here](https://www.linuxquestions.org/questions/linux-server-73/difference-between-initrd-and-vmlinuz-images-892868/).
   - Only kernel is verified with UEFI certificates in default configuration. So, Initrd should be signed with GPG.

##### Kernel & Initrd

Kernel then:

1. Executes init script from initrd.
2. The init scripts does whatever it needs to mount real FS.
3. And finally, replaces itself with real `/sbin/init` from real FS.

##### EFI Stub & Systemd-boot

There are other options however. Linux kernel is provided as a EFI binary, and therefore can be verified and loaded directly by UEFI firmware. This has a number of advantages:

- This approach is much simpler
  - fewer moving parts
  - faster boots (in qemu VM 57s in case of shim/GRUB vs 11s in case of unified kernel image)
  - decreased surface for helpful "features" (such as MokManager)
- Fewer files to sign:
  - surface for mistake is less.
  - no need to create GPG keys.

The only thing that needs to be addressed in this scenario is initrd. Luckily, it is possible to create a "unified kernel image" that includes everything that is needed to start kernel (kernel itself, initrd, kernel start options). The image then can be signed as usual and loaded by UEFI firmware.

To give you a taste of how simpler this option is, below a complete example of making non-unified kernel boot: (in case of unified kernel image, we need one invocation of `objcopy` command before):

```
efibootmgr -c -L MyEFIStubLinux -l /vmlinuz.efi -u 'initrd=\initrd.img root=/dev/mapper/vgkubuntu-root ro'
```

- Where the value of the `-u ` option can be copied from `/proc/cmdline`.
- And `vmlinuz.efi` and `initrd.img ` should be copied from `/boot` to `/boot/efi`.

##### Other

Note, that some TPMs (Titan M) can start even before (1), checking integrity of itself and UEFI, and only then starting CPU.

Types of boot:

- Thorough or Full Boot provides the maximum amount of protection by using Secure Boot throughout the boot process. Integrity, signature, and hash checks are performed.
- Fast Boot or Minimal Boot minimizes boot time by skipping numerous checks, which may or may not include Secure Boot checks. Boot speed is prioritized over some security features and/or additional features and peripheral support at boot time. Malware like LoJax can slip by on some systems (Schlej 2018). When Fast Boot is a configurable toggle, disabling Fast Boot typically results in Thorough Boot.
- Automatic Boot attempts to detect when changes have occurred to the early stages of UEFI boot. Automatic Boot invokes Fast/Minimal Boot when no changes are detected. Thorough/Full Boot is invoked once after each significant change is detected.

## The plan

Below we are going to:

- Generate our own SSL keys and certificates. The keys can be stored on both: filesystem and Yubikey.
- (Only if you chose to use GRUB) Generate our own GPG keys. The keys can be stored on both: filesystem and Yubikey.
- Remove existing signatures from UEFI binaries (in `/boot/efi`) and sign them and Linux kernel (`vmlinuz-`) with SSL.
- (Only if you chose to use GRUB) Sign Linux kernel, initrd, grub configs with GPG.
- (Only if you chose to use GRUB) Configure GRUB in such a way that it verifies everything it loads, and create a password-protected `root` user for GRUB.
- (Only if you chose to use EFI Stub) Create a unified kernel image.
- Reboot and enroll SSL certificates in UEFI.

We also want to simplify and automate the process because we will need to run it repeatedly (potentially, on each system update).


## Customisation points & Low-level Tools

There will be a helper script, but it is always useful to understand how to accomplish each step yourself. You might need it in case something goes wrong and you need to fix it from a live usb.

### SSL Certificates in UEFI

##### Get the list

Get the list of existing and enrolled certificates in UEFI:

- Using `efi-readvar` (Install package: `sudo apt install efitools`)
  - `efi-readvar`  - will print everything.
  - Extract PK/KEK/db via:  `efi-readvar -v PK -o PK.old.esl` and save the files somewhere.
  - Extract der certificates from ESL with: `sig-list-to-certs sec_out/KEK.old.esl KEK`
- Using `mokutil`: `mokutil --pk`, `mokutil --kek`, `mokutil --db`, `mokutil --list-enrolled`.

##### View details

- `openssl x509 -inform pem -in PK.crt -text`
- `openssl x509 -inform der -in /var/lib/shim-signed/mok/MOK.der -text`
